<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moon Scan Value Calculator</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #f4f4f4; }
        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
        th, td { border: 1px solid black; padding: 8px; text-align: left; }
        .bold { font-weight: bold; }
        textarea { width: 100%; height: 200px; margin-bottom: 10px; }
        button { padding: 10px 20px; cursor: pointer; }
        #output { margin-top: 20px; }
        .alert { color: red; margin-bottom: 10px; }
        .price-list { margin-bottom: 10px; }
        .fetch-status { margin-bottom: 10px; color: green; }
        .fetch-status.failed { color: red; }
        .retry-note { color: orange; font-style: italic; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Moon Scan Value Calculator</h1>
    <p>Paste moon scan data in the textarea below and click Calculate to generate tables with rarity (ore R ratings), composition, hourly yields, per-unit ISK, ISK per hour, and total ISK for 30 days for Athanor and Metenox. Handles leading/trailing whitespace and blank lines. Prices are fetched from Fuzzwork API (Jita region min sell) for refined products and displayed above the table with API fetch status. If fetch fails, verified defaults (October 9, 2025) are used. Run on a local server to minimize CORS issues: <code>python -m http.server 8000</code> and access <code>http://localhost:8000</code>.</p>
    <textarea id="input" placeholder="e.g., CZ6U-1 I - Moon 17\nCobaltite 0.309334159 45494 ..."></textarea><br>
    <button onclick="calculate()">Calculate</button>
    <div id="output"></div>

    <script>
        // Ore type definitions (Cerlestes, per 1,000 m続 at 100% efficiency)
        const oreTypes = {
            45490: {name: 'Zeolites', goo: 'Atmospheric Gases', gooAmt: 65, pyr: 8000, mex: 400, type: 'R4'},
            45491: {name: 'Sylvite', goo: 'Evaporite Deposits', gooAmt: 65, pyr: 4000, mex: 400, type: 'R4'},
            45492: {name: 'Bitumens', goo: 'Hydrocarbons', gooAmt: 65, pyr: 8000, mex: 400, type: 'R4'},
            45493: {name: 'Coesite', goo: 'Silicates', gooAmt: 65, pyr: 3000, mex: 400, type: 'R4'},
            45494: {name: 'Cobaltite', goo1: 'Platinum', goo1Amt: 20, goo2: 'Cobalt', goo2Amt: 10, pyr: 400, mex: 40, type: 'R8'},
            45496: {name: 'Titanite', goo1: 'Titanium', goo1Amt: 20, goo2: 'Chromium', goo2Amt: 10, pyr: 400, mex: 40, type: 'R16'},
            45498: {name: 'Otavite', goo1: 'Cadmium', goo1Amt: 20, goo2: 'Chromium', goo2Amt: 10, pyr: 400, mex: 40, type: 'R16'},
            45499: {name: 'Sperrylite', goo1: 'Platinum', goo1Amt: 20, goo2: 'Cadmium', goo2Amt: 10, pyr: 400, mex: 40, type: 'R16'},
            45500: {name: 'Vanadinite', goo1: 'Vanadium', goo1Amt: 20, goo2: 'Technetium', goo2Amt: 10, pyr: 400, mex: 40, type: 'R16'},
            45501: {name: 'Chromite', goo1: 'Chromium', goo1Amt: 20, goo2: 'Cadmium', goo2Amt: 10, pyr: 400, mex: 40, type: 'R16'},
            45511: {name: 'Monazite', goo1: 'Neodymium', goo1Amt: 10, goo2: 'Morphite', goo2Amt: 1, pyr: 400, mex: 40, type: 'R64'},
            45512: {name: 'Loparite', goo1: 'Promethium', goo1Amt: 10, goo2: 'Morphite', goo2Amt: 1, pyr: 400, mex: 40, type: 'R64'},
            45513: {name: 'Ytterbite', goo1: 'Dysprosium', goo1Amt: 10, goo2: 'Morphite', goo2Amt: 1, pyr: 400, mex: 40, type: 'R64'}
        };

        // Fallback prices (Verified Jita Min Sell, October 9, 2025)
        let prices = {
            'Pyerite': 26.0, 'Mexallon': 54.0, 'Hydrocarbons': 555.0, 'Atmospheric Gases': 365.0,
            'Evaporite Deposits': 370.0, 'Silicates': 420.0, 'Titanium': 1002.0, 'Cadmium': 6562.0,
            'Cobalt': 850.0, 'Chromium': 7627.0, 'Vanadium': 2112.0, 'Platinum': 7145.0,
            'Technetium': 12480.0, 'Neodymium': 14140.0, 'Promethium': 61000.0, 'Dysprosium': 67000.0, 'Morphite': 20200.0
        };

        // Track if live prices are used and fetch errors
        let isLivePrices = false;
        let fetchErrors = [];

        // Fetch live prices from Fuzzwork API
        async function fetchPrices() {
            const typeIds = {
                'Pyerite': 35, 'Mexallon': 36, 'Hydrocarbons': 16633, 'Atmospheric Gases': 16634,
                'Evaporite Deposits': 16635, 'Silicates': 16636, 'Titanium': 16638, 'Cadmium': 16643,
                'Cobalt': 16640, 'Chromium': 16641, 'Vanadium': 16642, 'Platinum': 16644,
                'Technetium': 16649, 'Neodymium': 16648, 'Promethium': 16652, 'Dysprosium': 16650, 'Morphite': 11396
            };
            const typeIdList = Object.values(typeIds).join(',');
            const url = `https://market.fuzzwork.co.uk/aggregates/?region=10000002&types=${typeIdList}`;
            fetchErrors = [];
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
                const data = await response.json();
                const updatePrice = (id, key) => {
                    const price = parseFloat(data[id]?.sell?.min);
                    if (!isNaN(price) && price > 0) {
                        prices[key] = price;
                    } else {
                        console.warn(`Invalid price for ${key} (type ${id}): ${data[id]?.sell?.min}`);
                        fetchErrors.push(`Failed for ${key}: Invalid price (${data[id]?.sell?.min})`);
                    }
                };
                updatePrice('35', 'Pyerite');
                updatePrice('36', 'Mexallon');
                updatePrice('16633', 'Hydrocarbons');
                updatePrice('16634', 'Atmospheric Gases');
                updatePrice('16635', 'Evaporite Deposits');
                updatePrice('16636', 'Silicates');
                updatePrice('16638', 'Titanium');
                updatePrice('16643', 'Cadmium');
                updatePrice('16640', 'Cobalt');
                updatePrice('16641', 'Chromium');
                updatePrice('16642', 'Vanadium');
                updatePrice('16644', 'Platinum');
                updatePrice('16649', 'Technetium');
                updatePrice('16648', 'Neodymium');
                updatePrice('16652', 'Promethium');
                updatePrice('16650', 'Dysprosium');
                updatePrice('11396', 'Morphite');
                isLivePrices = fetchErrors.length === 0;
                console.log('Live prices fetched:', prices);
                if (!isLivePrices) {
                    console.error('Some price fetches failed:', fetchErrors);
                }
            } catch (e) {
                console.error('Fallback to verified prices:', e);
                fetchErrors.push(`Global fetch error: ${e.message}`);
                isLivePrices = false;
            }
        }

        // Format numbers
        function formatNumber(num, isISK = false) {
            if (isNaN(num) || num === null || num === undefined) return '0';
            if (isISK) return Math.round(num).toLocaleString('en-US');
            return num >= 1000 ? Math.round(num / 1000) + 'k' : Math.round(num);
        }

        function isR8OrHigher(id) {
            return id >= 45494;
        }

        // Parse input lines with whitespace handling
        function parseInput(input) {
            const lines = input.split('\n').map(line => line.trim()).filter(line => line);
            let currentMoon = '';
            const moons = [];
            let currentData = {};
            lines.forEach(line => {
                if (line.startsWith('Moon Moon Product')) {
                    console.log('Skipped header:', line);
                    return;
                }
                if (line.match(/^\s*[A-Z0-9]+-[A-Z0-9]+.* - Moon \d+/)) {
                    if (currentMoon) moons.push({name: currentMoon, data: {...currentData}});
                    currentMoon = line;
                    currentData = {};
                    console.log('Parsed moon:', currentMoon);
                } else if (line.match(/^\s*[A-Z][a-zA-Z]+\s+\d+\.\d+\s+\d+\s+\d+\s+\d+\s+\d+/)) {
                    const parts = line.split(/\s+/);
                    const product = parts[0];
                    const quantity = parseFloat(parts[1]);
                    const typeID = parseInt(parts[2]);
                    if (!isNaN(quantity) && typeID && oreTypes[typeID]) {
                        currentData[typeID] = {product, quantity};
                        console.log(`Parsed ore: ${product}, ${quantity}, ${typeID}`);
                    } else {
                        console.log(`Invalid ore line: ${line}`);
                    }
                } else {
                    console.log(`Skipped line: ${line}`);
                }
            });
            if (currentMoon) moons.push({name: currentMoon, data: {...currentData}});
            console.log('Parsed moons:', moons);
            return moons;
        }

        // Calculate for one moon
        async function calculateMoon(moonName, data) {
            let composition = '';
            let rarities = [];
            let athanorYields = {};
            let metenoxYields = {};
            let athanorIsk = 0;
            let metenoxIsk = 0;
            let athanorUnitIsk = [];
            let metenoxUnitIsk = [];
            let isHighValue = false;
            const totalChunks = 30; // 30,000 m続/h = 30 chunks of 1,000 m続
            const reprocessYield = 0.906;
            const metenoxFactor = 0.4; // 40% efficiency = 12,000 m続/h = 12 chunks

            // Consolidate yields and collect rarities
            Object.entries(data).forEach(([typeID, {product, quantity}]) => {
                const oreInfo = oreTypes[typeID];
                if (!oreInfo) {
                    console.log(`Unknown ore typeID: ${typeID}`);
                    return;
                }
                composition += `${oreInfo.name} ${(quantity * 100).toFixed(2)}%, `;
                rarities.push(`${oreInfo.name} (${oreInfo.type})`);
                if (isR8OrHigher(typeID)) isHighValue = true;
                const chunks = totalChunks * quantity;
                if (oreInfo.goo) {
                    const gooUnits = chunks * oreInfo.gooAmt * reprocessYield;
                    athanorYields[oreInfo.goo] = (athanorYields[oreInfo.goo] || 0) + gooUnits;
                    metenoxYields[oreInfo.goo] = (metenoxYields[oreInfo.goo] || 0) + gooUnits * metenoxFactor;
                }
                if (oreInfo.goo1) {
                    const goo1Units = chunks * oreInfo.goo1Amt * reprocessYield;
                    athanorYields[oreInfo.goo1] = (athanorYields[oreInfo.goo1] || 0) + goo1Units;
                    metenoxYields[oreInfo.goo1] = (metenoxYields[oreInfo.goo1] || 0) + goo1Units * metenoxFactor;
                    if (oreInfo.goo2) {
                        const goo2Units = chunks * oreInfo.goo2Amt * reprocessYield;
                        athanorYields[oreInfo.goo2] = (athanorYields[oreInfo.goo2] || 0) + goo2Units;
                        metenoxYields[oreInfo.goo2] = (metenoxYields[oreInfo.goo2] || 0) + goo2Units * metenoxFactor;
                    }
                }
                const pyrUnits = chunks * oreInfo.pyr * reprocessYield;
                const mexUnits = chunks * oreInfo.mex * reprocessYield;
                athanorYields['Pyerite'] = (athanorYields['Pyerite'] || 0) + pyrUnits;
                athanorYields['Mexallon'] = (athanorYields['Mexallon'] || 0) + mexUnits;
            });

            // Calculate ISK values from consolidated yields
            Object.entries(athanorYields).forEach(([material, units]) => {
                const price = prices[material] || 0;
                athanorIsk += units * price;
                athanorUnitIsk.push(`${material} ${formatNumber(units * price, true)} (${formatNumber(price, true)} ISK/unit)`);
            });
            Object.entries(metenoxYields).forEach(([material, units]) => {
                const price = prices[material] || 0;
                metenoxIsk += units * price;
                metenoxUnitIsk.push(`${material} ${formatNumber(units * price, true)} (${formatNumber(price, true)} ISK/unit)`);
            });

            if (!composition) {
                console.log('No valid composition for moon:', moonName);
                return null;
            }
            composition = composition.slice(0, -2);
            const rarityStr = rarities.join(', ');
            const athanorYieldStr = Object.entries(athanorYields).map(([k, v]) => `${k} ${formatNumber(v)}`).join(', ');
            const metenoxYieldStr = Object.entries(metenoxYields).map(([k, v]) => `${k} ${formatNumber(v)}`).join(', ');
            const athanorUnitIskStr = athanorUnitIsk.join(', ');
            const metenoxUnitIskStr = metenoxUnitIsk.join(', ');
            const athanorIskStr = formatNumber(athanorIsk, true);
            const metenoxIskStr = formatNumber(metenoxIsk, true);
            const athanorTotal = formatNumber(athanorIsk * 720, true);
            const metenoxTotal = formatNumber(metenoxIsk * 720, true);
            const classStr = isHighValue ? ' class="bold"' : '';
            return {
                row: `<tr${classStr} data-isk="${athanorIsk}"><td>${moonName || 'Unknown Moon'}</td><td>${rarityStr || 'N/A'}</td><td>${composition || 'N/A'}</td><td>${athanorYieldStr || 'N/A'}</td><td>${athanorUnitIskStr || 'N/A'}</td><td>${athanorIskStr}</td><td>${athanorTotal}</td><td>${metenoxYieldStr || 'N/A'}</td><td>${metenoxUnitIskStr || 'N/A'}</td><td>${metenoxIskStr}</td><td>${metenoxTotal}</td></tr>`,
                athanorIsk
            };
        }

        // Main calculate function
        async function calculate() {
            await fetchPrices();
            const input = document.getElementById('input').value.trim();
            const moons = parseInput(input);
            if (moons.length === 0) {
                document.getElementById('output').innerHTML = '<div class="alert">No valid moon data parsed. Ensure format matches: SYSTEM - Moon X Ore % TypeID ... or includes header. Check console for errors.</div>';
                return;
            }
            currentTableRows = [];
            let output = '<h2>Moon Scan Results</h2>';
            output += `<div class="fetch-status${isLivePrices ? '' : ' failed'}">API Fetch: ${isLivePrices ? 'Success (Live Fuzzwork API prices used)' : `Failed (Using verified fallback prices from October 9, 2025${fetchErrors.length ? ': ' + fetchErrors.join('; ') : ''})`}</div>`;
            output += '<div class="price-list">Per-Unit Prices (ISK/unit):<br>' +
                Object.entries(prices).map(([key, value]) => `${key}: ${formatNumber(value, true)}${fetchErrors.some(err => err.startsWith(`Failed for ${key}`)) ? ' (fallback)' : ''}`).join('<br>') +
                '</div>';
            output += '<div class="retry-note">Note: Run on a local server to minimize CORS issues: <code>python -m http.server 8000</code> and access <code>http://localhost:8000</code>.</div>';
            output += '<button onclick="sortTable()">Sort by Highest Athanor ISK/h</button>';
            output += '<table id="resultsTable"><tr><th>Moon</th><th>Rarity</th><th>Composition (% Ore)</th><th>Athanor Yields/h (Goo + Base)</th><th>Athanor Per-Unit ISK/h</th><th>Athanor ISK/h</th><th>Athanor Total ISK/30 days</th><th>Metenox Yields/h (Goo)</th><th>Metenox Per-Unit ISK/h</th><th>Metenox ISK/h</th><th>Metenox Total ISK/30 days</th></tr>';
            const results = await Promise.all(moons.map(moon => calculateMoon(moon.name, moon.data)));
            results.filter(row => row !== null).forEach(row => {
                currentTableRows.push(row.row);
                output += row.row;
            });
            if (currentTableRows.length === 0) {
                document.getElementById('output').innerHTML = '<div class="alert">No valid calculations produced. Check console for errors.</div>';
                return;
            }
            output += '</table>';
            document.getElementById('output').innerHTML = output;
        }

        // Sort table
        function sortTable() {
            currentTableRows.sort((a, b) => {
                const iskA = parseFloat(a.match(/data-isk="(\d+(\.\d+)?)"/)?.[1] || 0);
                const iskB = parseFloat(b.match(/data-isk="(\d+(\.\d+)?)"/)?.[1] || 0);
                return iskB - iskA;
            });
            let output = '<h2>Moon Scan Results (Sorted by Highest Athanor ISK/h)</h2>';
            output += `<div class="fetch-status${isLivePrices ? '' : ' failed'}">API Fetch: ${isLivePrices ? 'Success (Live Fuzzwork API prices used)' : `Failed (Using verified fallback prices from October 9, 2025${fetchErrors.length ? ': ' + fetchErrors.join('; ') : ''})`}</div>`;
            output += '<div class="price-list">Per-Unit Prices (ISK/unit):<br>' +
                Object.entries(prices).map(([key, value]) => `${key}: ${formatNumber(value, true)}${fetchErrors.some(err => err.startsWith(`Failed for ${key}`)) ? ' (fallback)' : ''}`).join('<br>') +
                '</div>';
            output += '<div class="retry-note">Note: Run on a local server to minimize CORS issues: <code>python -m http.server 8000</code> and access <code>http://localhost:8000</code>.</div>';
            output += '<button onclick="calculate()">Recalculate</button>';
            output += '<table id="resultsTable"><tr><th>Moon</th><th>Rarity</th><th>Composition (% Ore)</th><th>Athanor Yields/h (Goo + Base)</th><th>Athanor Per-Unit ISK/h</th><th>Athanor ISK/h</th><th>Athanor Total ISK/30 days</th><th>Metenox Yields/h (Goo)</th><th>Metenox Per-Unit ISK/h</th><th>Metenox ISK/h</th><th>Metenox Total ISK/30 days</th></tr>';
            currentTableRows.forEach(row => output += row);
            output += '</table>';
            document.getElementById('output').innerHTML = output;
        }
    </script>
</body>
</html>
